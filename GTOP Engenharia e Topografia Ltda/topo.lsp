;;; Aplicativos para topografia e cartografia

;(defun ERROS (/ msg)
;	(terpri)
;	(if (= msg "Function cancelled") (princ (strcat "\nFuncao Cancelada" "\n")))1
;	(if (= msg "AutoCAD regected function")(princ (strcat "\nFuncao regeitada pelo AutoCAD" "\n")))
;	(if (= msg "Bad argument type")(princ (strcat "\nTipo de argumento incorreto" "\n")))
;	(if (= msg "Console break")(princ (strcat "\n<CTRL> <C>. " "\n")))
;	(if (= msg "Too few arguments")(princ (strcat "\nForam fornecidos poucos argumentos." "\n")))
;	(if (= msg "Too many arguments")(princ (strcat "\nForam fornecidos muitos argumentos." "\n")))
;	(if (= msg "Invalid point")(princ (strcat "\nPonto invalido" "\n")))
;
;	(if (= msg "AutoLISP stack overflow")(princ (strcat "\nAutoLISP: Pilha de Memoria Esgotada." "\n")))
;	(if (= msg "Bad association list")(princ (strcat "\nAssociacao de lista incorreta." "\n")))
;	(if (= msg "Bad conversion code")(princ (strcat "\nConversao de codigo incorreta." "\n")))
;	(if (= msg "Bad ENTMOD list")(princ (strcat "\nLista com ENTMODE incorreta." "\n")))
;	(if (= msg "Bad ENTMOD list value")(princ (strcat "\nValor na lista ENTMODE incorreto." "\n")))
;	(princ)
;)

;(setq old_error *error*        
;      *error* erros             
;)

(defun tira_ponto (TEXTO / AUX j txt )
  	(setq comp (strlen TEXTO))
        (setq i 0)
        (setq aux "")
        (repeat (strlen TEXTO)
	  	(setq txt (substr TEXTO (setq i(1+ i)) 1))
	        (cond
		  ((= txt ".") (setq AUX (strcat aux "," )))
	          ((/= txt ".") (setq AUX (strcat aux txt )))
		 )
	)
  	(setq aux aux)
 )
(defun frac (x)
 (- x (fix x))
)

(defun dtr (a)
   (* pi (/ a 180.0))
)

(defun rtd (a)
   (/ (* a 180.0) pi)
)

(defun c:KR()
(princ "\nAtualizacao do KR.")
    (capaerre)
    (princ (strcat "\nEntre com KR <" (rtos KR 2 7) "> : "))
    (setq temp KR)
    (setq KR (getreal))
    (if (= KR nil) (setq KR temp))
    (SETVAR "USERR1" KR)
    (princ (strcat "\nKR atual ==> " (rtos KR 2 7)))
    (princ)
)

(defun capaerre()
    (if (< (GETVAR "USERR1") 1.0)
      (progn
	(setq KR 1.0000000)
	(princ "\nKR nao cadastrado!!!")
	(princ (strcat "\nEntre com KR <" (rtos KR 2 7) "> : "))
	(setq temp KR)
	(setq KR (getreal))
	(if (= KR nil) (setq KR temp))
	(princ (strcat "\nKR atual ==> " (rtos KR 2 7)))
	(SETVAR "USERR1" KR)
      )
    )

    (if (not KR)
      (progn
	(setq KR (GETVAR "USERR1"))
	(setq hakr 1)
      )
    )

    (princ (strcat "\nKR atual ==> " (rtos KR 2 7)))
    (princ)
)


(defun c:rpolar (/ zero ptorigem angulo distancia pontos retas ptfim )
(prompt "\nDesenha uma reta atraves de coordenadas polares.")
    (setq zero 0.0)
    (setq ptorigem (getpoint "\nEntre com a origem:  "))
    (capaerre)
    (resetang)
    (princ "\nDe a direcao: ")
    (setq angulo (getangle ptorigem))
    (princ "\nQuer colocar pontos nas extremidades(S/N) ? <S>: ")
    (setq pontos (getstring))
    (princ "\nQuer desenhas as retas(S/N) ? <S>: ")
    (setq retas (getstring))
    (princ "\nEntre com a distancia: ")
    (setq distancia (getreal))
    (setq distancia (* distancia KR))
    (setq ptfim (polar ptorigem angulo distancia))
    (if (or (= pontos "s") (= pontos "S") (= pontos ""))
    (progn
	    (command "point" ptorigem)
	    (command "point" ptfim)
       )
    )
    (if (or (= retas "s") (= retas "S") (= retas ""))
	    (command "line" ptorigem ptfim "")
    )
    (setq ptorigem ptfim)
    (princ "\nEntre com a distancia: ")
    (setq distancia (getreal))
    (while (/= distancia nil)
   (setq distancia (* distancia KR))
	(setq ptfim (polar ptorigem angulo distancia))
	(if (or (= retas "s") (= retas "S") (= retas ""))
	    (command "line" ptorigem ptfim "")
	)
	(if (or (= pontos "s") (= pontos "S") (= pontos ""))
	    (command "point" ptfim)
	)
	(setq ptorigem ptfim)
	(princ "\nEntre com a distancia: ")
	(setq distancia (getreal))
   )
   (initang)
)



(defun c:cota(/ nc)
(prompt "\nCalcula e cota a distancia entre dois pontos.")

    (setq hakr 0)
    (setq hapt 0)
    (setq hasize 0)
    (setq zero 0.0)
    (initang)
    (capaerre)
    (ver_regua)
    (if (not tampt)
      (progn
	(setq tampt (* escala 0.001))
	(princ (strcat "\nQual o tamanho do ponto <" (rtos tampt 2 2) "> : "))
	(setq temp tampt)
	(setq tampt (getreal))
	(if (not tampt) (setq tampt temp))
	(princ (strcat "\nTamanho atual ==> " (rtos tampt 2 2)))
	(setq hasize 1)
      )
    )
    (if (/= hasize 1)
      (progn
	(princ (strcat "\nQual o tamanho do ponto <" (rtos tampt 2 2) "> : "))
	(setq temp tampt)
	(setq tampt (getreal))
	(if (= tampt nil) (setq tampt temp))
	(princ (strcat "\nTamanho atual ==> " (rtos tampt 2 2)))
      )
    )
    (setq ptorigem (getpoint "\nDefina o ponto inicial."))
    (setq ptfim (getpoint ptorigem "\nDefina o ponto final."))
    (setq D1 (distance ptorigem ptfim))
    (setq old_osmode (getvar "OSMODE"))
    (setvar "OSMODE" 0)
    ;(command "insert" "dot1=" ptorigem tampt tampt "")
   ; (command "insert" "dot1" ptfim tampt tampt "")
    (setq DF (/ D1 KR))
    (princ "\nDistancia Reduzida do KR ==> ")
    (princ DF)
    (setq No (cadr ptorigem))
    (setq Eo (car  ptorigem))
    (setq Nf (cadr ptfim))
    (setq Ef (car  ptfim))
    (setq Nm (/ (+ No Nf) 2))
    (setq Em (/ (+ Eo Ef) 2))
    (setq ptmedio (list Em Nm))
    (setq angulo (angle ptorigem ptfim))
    (setq delta_e (- Ef Eo))
    (setq delta_n (- Nf No))
    (setq angulo (rtd angulo))
    (if (and (<= delta_e zero) (<= delta_n zero))      ;; 3o Quadrante
	(progn 
	   (setq angulo (- angulo 180))
	)
	(if (and (<= delta_e zero) (>= delta_n zero))    ;; 4o Quadrante
	    (progn
	       (setq angulo (- angulo 180))
	    )
	)
    )
	(setq NC (Getint "\nNumero de casas decimais para a escrita <2>: "))
	(if (= nc nil) (setq nc 2))
	(setq DISTCONV (rtos DF 2 nc))
    (setq h (getvar "TEXTSIZE"))
    (setq angfinal (- 90 angulo))
	(setq DISTCONV (tira_ponto DISTCONV))
    (command "TEXT" "m" ptmedio h angfinal DISTCONV)
    (setvar "OSMODE" old_osmode)
    (princ)
)



(defun c:dk (/ afasta pt1 pt2 df ang temp1 temp2 ptxt pe h distconv nc )
(prompt "\nCalcula e escreve a distancia entre dois pontos.")
    (initang)
    (setq old_osmode (getvar "OSMODE"))
    ;;;(setvar "osmode" 41)
    (setq hakr 0)
    (capaerre)
    (ver_regua)
    (setq afasta (* (/ escala fator) 0.7)) 
    (if (= nc nil) (setq nc 2))       
    (setq NC (Getint "\nNumero de casas decimais para a escrita <2>: "))
    ;;(princ "\nNumero de casas decimais para a escrita: 2")
    (prompt "\nPara parar use <ENTER> ou o botao direito do Mouse")
    (setvar "osmode" 1)
    (setq Pt1    (Getpoint "\nPonto inicial: "))
    (setq PE (strcase (Getstring "\nPosicao da escrita <C> acima ou <B> abaixo? < C >: ")))
    (if (and (/= PE "C") (/= PE "B")) (setq PE "C") )    
    (if (= PE nil) (setq PE "C"))           
    (while Pt1
		   (setq Pt1 (list (car pt1) (cadr pt1) 0))
		   (setq Pt2 (Getpoint pt1 "\nPonto final (INT/END/NOD): "))
		   (setq Pt2 (list (car pt2) (cadr pt2) 0))       
		   (setq DF  (/ (distance pt1 pt2) KR))
		   (princ "\nDistancia Reduzida do KR ==> ")
		   (princ DF)
		   (setq ang (- 90 (rtd (angle pt1 pt2) )))
		   (setq temp1 (/ (+ (car  pt1) (car  pt2) ) 2) 
		      temp2 (/ (+ (cadr pt1) (cadr pt2) ) 2)
			      ptxt  (list temp1 temp2 0)
		   )
                   (setvar "osmode" 0)
		   (cond
		   	( (= NC 0) (setq DISTCONV (rtos DF 2 0)))
		   	( (= NC 1) (setq DISTCONV (rtos DF 2 1)))
		   	( (= NC 2) (setq DISTCONV (rtos DF 2 2)))
		   	( (= NC 3) (setq DISTCONV (rtos DF 2 3)))
		   	( (= NC 4) (setq DISTCONV (rtos DF 2 4)))
			( T (setq DISTCONV (rtos DF 2 2)))
		   )
		   (SETQ DISTCONV (TIRA_PONTO DISTCONV))
		   (setq h (getvar "TEXTSIZE"))
		   (if (= PE "C")
				(command "_.TEXT" "BC" PTXT h ang DISTCONV)
		   )
		   (if (= PE "B")
				 (progn
			(setq ptxt (polar ptxt (- (angle pt1 pt2) (/ pi 2.0)) afasta))    
					(command "_.TEXT" "TC" PTXT h ang DISTCONV)
				 )
		   )
		   (princ)
                  (setvar "osmode" 1)
	          (setq Pt1 Pt2)                 
    )
    (setvar "osmode" old_osmode)
	  (princ)

)


(defun c:dt()
(prompt "\nInforma a distancia entre dois pontos.")
    (initang)
    (setq hakr 0)
    (capaerre)
    (princ "\nEntre com o ponto inicial e o ponto final!!!")
    (setq D1 (getdist))
    (setq DF (/ D1 KR))
    (alert (strcat "DISTANCIA REDUZIDA DO KR\n\n" "      "(rtos DF 2 4) " m"))
)


(defun xx()
  (leroy_)
  (princ)
)

(defun c:leroy() (xx))


(defun c:CO2( / DX)
(prompt "\nEscreve as coordenadas de um ponto (2D).")
    (initang)
    (command "_.layer" "m" "TOP-TXT_COORDENADA" "")
    (ver_regua)
    (setq h (getvar "TEXTSIZE"))
    (setq pt (getpoint "\nAponte um ponto."))
    (setq E (car pt))
    (setq E1 (rtos E 2 4)) 
    (setq tam (strlen E1))
    (setq E1 (strcat (substr E1 1 3) "." (substr E1 4 3) "," (substr E1 8 4) ))
    (setq E1 (strcat "E="  E1))
	(setq N (cadr pt))
    (setq N1 (rtos N 2 4))
    (setq N1 (strcat (substr N1 1 1) "." (substr N1 2 3) "." (substr N1 5 3) "," (substr N1 9) ))
    (setq N1 (strcat "N="  N1))
    (setq pt1 (getpoint "\nCoordenada N. Defina a origem."))
    (setq DX (- (car pt1) (car pt)))
    (setq pt2 (cal "pt1-[0,0.5*h]"))
    (command "_.TEXT" pt1 h 90 N1)
    (setq pt1 (cal "pt1-[0,2*h]"))
    (command "_.TEXT" pt1 h 90 E1)
    (command "_.layer" "m" "TOP-LINHA_CHAMADA" "")
    (setq pt1 (cal "pt2+[14*h,0]"))
    (command "_.Pline" pt1 pt2 "") 
    (if (> DX 0.0)
    	(command "_.Pline" pt2 pt "")
        (command "_.Pline" pt1 pt "")
    )  
    (princ)
)


(defun c:COI()
(prompt "\nInforma as coordenadas de um ponto.")
    (initang)
    (setq pt (getpoint "\nAponte um ponto."))
    (setq N (cadr pt))
    (setq E (car pt))
    (alert (strcat "    COORDENADAS SICAD\n\n" "N=" (rtos N 2 4) " E=" (rtos E 2 4))); ESTAVA 2 4 ALTEREI PARA 2 3
    (princ)
)



(defun c:AZE()
(prompt "\nCalcula e escreve o azimute.")
    (setq zero 0.0)
    (capaerre)
    (ver_regua)
    (setq pt1 (getpoint "\nEntre com a origem:  "))
    (setq pt2 (getpoint "\nEntre o ponto final: "))
    (azdt pt1 pt2)
   (princ "\nAzimute da direcao ==> ")
   (princ azimuteg)
   (princ "\nAnotando o azimute:")
   (setq pt1 (getpoint "\nDefina a origem:"))
   (setq ang (getorient pt1 "\nDe a direcao:"))
   (setq h (getvar "TEXTSIZE"))
   (command "_.TEXT" pt1 h (- 90 (rtd ang)) azimuteg)
   (princ)
)




(defun c:AZI()
(prompt "\nInforma o azimute")
    (setq zero 0.0)
    (setq pt1 (getpoint "\nEntre com a origem:  "))
    (setq pt2 (getpoint "\nEntre o ponto final: "))
    (azdt pt1 pt2)
   (alert (strcat "Azimute da direcao\n\n" azimutec))
)


(defun c:ACP(/ RAREA VAREA V_AREA V_PERIM TEXTO)
(prompt "\nCalculo de area.")
    (INITANG)
    (setq hakr 0)
    (capaerre)
    (ver_regua)
    (princ "\nCalculo de area de um poligono.\n")
    (While  (princ "\nSelecione circulo ou polilyne.\n")
       (progn
    		(command "_area" "_ENTITY" pause)
    		(setq rarea (getvar "area"))
    		(setq varea (/ rarea (* kr kr)))
    		(setq perimetro (/ (getvar "perimeter") kr))
    		(princ "\nArea corrigida ==> ")
    		(princ varea)
    		(princ "\nPerimetro corrigido ==> ")
    		(princ perimetro)
    		(setq pttext (getpoint "\nTexto da area e perímetro. Defina a origem."))
    		(setq ang (getorient pttext "\nDe a direcao."))
    		(setq V_area (rtos varea 2 2))
    		(setq v_area (strcat "Área: " v_area "m2"))
                (setq V_PERIM (rtos perimetro 2 3))
                (setq V_PERIM (strcat "Perim: " V_PERIM "m"))
    		(setq h (getvar "TEXTSIZE"))
                (setq TEXTO (strcat v_area " - " V_PERIM))
		    (setq TEXTO (tira_ponto TEXTO));;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    		(command "_.TEXT" pttext h (- 90 (rtd ang)) TEXTO)
    		(princ)
      ))
)



(defun initang ()
    (setvar "ANGBASE" (/ pi 2))  
    (setvar "ANGDIR" 1)   
    (setvar "AUNITS" 1)   ; grau,minuto,segundo
    (setvar "AUPREC" 5)   ; 
    (setvar "LUNITS" 2)   ; decimal
    (setvar "LUPREC" 4)   

)

(defun resetang ()
    (setvar "ANGBASE" 0.0)  
    (setvar "ANGDIR"    0)   
    (setvar "AUNITS"    0)
    (setvar "AUPREC"    0)   
    (setvar "LUNITS"    2)   
    (setvar "LUPREC"    4)   
)

(defun leroy_()
(prompt "\nSeleciona reguas.")
    (command "regenauto" "off")
    (setq regua40  1.0)
    (setq regua50  1.3)
    (setq regua60  1.6)
    (setq regua80  2.0)
    (setq regua100 2.5)
    (setq regua120 3.0)
    (setq regua140 3.5)
    (setq regua175 4.0)
    (setq regua200 4.5)
    (setq regua240 6.0)
    (setq regua290 7.5)
    (setq regua350 9.0)
    (setq regua425 11.0)
    (setq regua500 13.0)
    (setq VERMELHO "1")
    (setq AMARELO  "2")
    (setq VERDE    "3")
    (setq AZULCYAN "4")
    (setq AZUL     "5")
    (setq MAGENTA  "6")
    (setq BRANCO   "7")
    (setvar "TEXTSIZE" regua60)
    (command "_.STYLE" "standard" "ROMANS" "0" "1.0" "0" "" "" "")
    (command "_.STYLE" "txt" "romans" "0" "1.0" "0" "" "" "")
    (command "_.STYLE" "ROMANS" "ROMANS" "0" "1.0" "0" "" "" "")
;   (setvar "CECOLOR" BRANCO)
    (setq fator 1000.00)
    (princ "\nMUDANCA DE REGUA:")
    (setq MSG1 "\n(40,50,60,80,100,120,140,175,")
    (setq MSG2 "200,240,290,350,425,500)")
    (setq PEDEESCALA "\nEntre com a escala do desenho ")
    (setq  flag1 0)
    (setq  flag2 0)
    (if (= REGUA nil)
      (progn
	(princ "\nREGUA nao cadastrada. Escolha a regua.\n")
	(setq PEDEREGUA (strcat MSG1 MSG2 " ==> "))
	(setq REGUA (getint PEDEREGUA))
	(setq flag1 1)
      )
    )
    (if (/= flag1 1)
      (progn
	(princ (strcat PEDEREGUA " <" (itoa REGUA) "> : "))
	(setq temp REGUA)
	(setq REGUA (getint))
	(if (= REGUA nil) (setq REGUA temp))
	(princ (strcat "\nNova Regua ==> " (itoa REGUA)))
      )
    )        
    (princ "\nMUDANCA DE ESCALA:")
    (if (= ESCALA nil)
      (progn
	(princ "\nESCALA nao cadastrada!!!\n")
	(setq PEDEESCALA (strcat PEDEESCALA "==> 1:")) 
	(setq ESCALA (getreal PEDEESCALA))
	(setq flag2 1)
	(setvar "ltscale" (* 5 (/ escala 1000)))
      )
    )
    (if (/= flag2 1)
      (progn
	(princ (strcat PEDEESCALA "<" (rtos ESCALA 2 0) "> 1:"))
	(setq temp ESCALA)
	(setq ESCALA (getreal))
	(if (= ESCALA nil) (setq ESCALA temp))
	(princ (strcat "\nNova Escala ==> 1:" (rtos ESCALA 2 0)))
	(setvar "ltscale" (* 5 (/ escala 1000)))
      )
    )        

    (if (= REGUA 40)
	(progn
	      (setq size (* regua40 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" VERMELHO)
	)
    )
    (if (= REGUA 50)
	(progn
	      (setq size (* regua50 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" VERMELHO)
	)
    )
    (if (= REGUA 60)
	(progn
	      (setq size (* regua60 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" AMARELO)
	)
    )
    (if (= REGUA 80)
	(progn
	      (setq size (* regua80 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" AMARELO)
	)
    )
    (if (= REGUA 100)
	(progn
	      (setq size (* regua100 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" VERDE)
	)
    )
    (if (= REGUA 120)
	(progn
	      (setq size (* regua120 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" AZULCYAN)
	)
    )
    (if (= REGUA 140)
	(progn
	      (setq size (* regua140 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" AZUL)
	)
    )
    (if (= REGUA 175)
	(progn
	      (setq size (* regua175 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" MAGENTA)
	)
    )
    (if (= REGUA 200)
	(progn
	      (setq size (* regua200 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" BRANCO)
	)
    )
    (if (= REGUA 240)
	(progn
	      (setq size (* regua240 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" BRANCO)
	)
    )
    (if (= REGUA 290)
	(progn
	      (setq size (* regua290 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" BRANCO)
	)
    )
    (if (= REGUA 350)
	(progn
	      (setq size (* regua350 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" BRANCO)
	)
    )
    (if (= REGUA 425)
	(progn
	      (setq size (* regua425 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" BRANCO)
	)
    )
    (if (= REGUA 500)
	(progn
	      (setq size (* regua500 (/ ESCALA fator)))
	      (setvar "TEXTSIZE" size)
;	      (setvar "CECOLOR" BRANCO)
	)
    )
)



(defun ver_regua()
    (cond ((= REGUA nil) (leroy_))
    )
    (if (/= REGUA nil) 
      (progn
	(princ (strcat "\nRegua ==> " (itoa REGUA)))
	(princ (strcat "       Escala ==> 1:" (rtos ESCALA 2 0)))
      )
    )
(princ)
)

;;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
(defun C:ADE4 ( / DX MEIO PT1 PT2 PT3 intsegundo TXTDS TXTsegundo DIST)
(prompt "\nCalcula e escreve azimute e distancia.")
    (setq hakr 0)
    (setq zero 0.0)
    (ver_regua)
    (setq h (getvar "TEXTSIZE"))
    (initang)
    (capaerre)
    (setvar "osmode" 1)
    (setq MEIO 0.0)
    (setq P1 (getpoint "\nPrimeiro ponto:"))
    (while
		(setvar "osmode" 1)
		(setq P2 (getpoint P1 "\nProximo ponto:"))
		(setvar "osmode" 0)
		(command "" P1 P2  "")
		;(setq No (atof(rtos(cadr P1) 2 11)))
		;(setq Eo (atof(rtos(car  P1) 2 11)))
		;(setq Nf (atof(rtos(cadr P2) 2 11)))
		;(setq Ef (atof(rtos(car  P2) 2 11)))
		(setq No (atof(rtos(cadr P1) 2 4)))
		(setq Eo (atof(rtos(car  P1) 2 4)))
		(setq Nf (atof(rtos(cadr P2) 2 4)))
		(setq Ef (atof(rtos(car  P2) 2 4)))
		(setq delta_e (- Ef Eo))
		(setq delta_n (- Nf No))
			(if (= delta_n zero)
				(setq AA "0.0000")
			 )
			(if (/= delta_n zero)
			   (progn 
			  (setq angrad (/ delta_e delta_n))
			  (setq AA (angtos (atan angrad) 0 11))
			   )
			)
		(setq angreal (atof AA))
			
		(if (and (>= delta_e zero) (>= delta_n zero)) ;; 1o Quadrante
		  (progn
			(princ "\n 1o quadrante")
			(setq angreal (- 90 angreal))
			(setq quadrante 1)
		  )
		  (if (and (>= delta_e zero) (<= delta_n zero)) ; 2o Quadrante
				(progn
					(princ "\n 2o quadrante")
					(setq angreal (- 270 angreal))
					(setq quadrante 2)
				)
				(if (and (<= delta_e zero) (<= delta_n zero));; 3o Quadrante
				  (progn
					  (princ "\n 3o quadrante")
					  (setq angreal (- 270 angreal))
					  (setq quadrante 3)
				  )
				  (if (and (<= delta_e zero) (>= delta_n zero));; 4o Quadrante
					(progn
						(princ "\n 4o quadrante")
						(setq angreal (- 450 angreal))
						(setq quadrante 4)
					)
				  )
				)
			  )
		)
		(setq grau (fix angreal))
		(setq temp (* 60 (- angreal grau)))
		(setq minuto (fix temp))
		(setq temp (* 60 (- temp minuto)))
		(setq grau (rtos grau 2 0))
		(if (= (strlen grau) 1) (setq grau (strcat "0" grau)))
		(setq minuto (rtos minuto 2 0))
		(if (= (strlen minuto) 1) (setq minuto (strcat "0" minuto)))
		(setq segundo "")
		(setq intsegundo (fix temp))
		(setq decsegundo (rtos( * (- temp intsegundo) 10) 2 0))
		(if (< intsegundo 10) (setq segundo (strcat "0" (rtos intsegundo 2 0)))(setq segundo (rtos intsegundo 2 0)))
		(if (= (strlen decsegundo) 0) (setq segundo (strcat segundo ",0")))
		(if (= (strlen decsegundo) 1) (setq segundo (strcat segundo "," decsegundo)))
		;;(if (= (strlen (rtos decsegundo 2 0)) 2) (setq segundo (strcat segundo "," (rtos decsegundo 2 0))))
		(setq AA (strcat "Az=" grau "%%D" minuto "'" segundo "\""))
		(resetang)
		(SETQ MEIO (cal "(P1+P2)/2"))
		(setq BB (angle P1 P2)
			DS (distance P1 P2)
			DS (/ DS KR)
			P3 (polar P1 BB (/ DS 2.0))
			P1 P2 
		)
		(setq TXTDS (tira_ponto (rtos DS 2 3)));;com precisão de três casas decimais
		(setq TXTDS (strcat TXTDS "m"))
		(setq angulo BB)
		(if (or (= quadrante 3) (= quadrante 4))
			(setq angulo (+ angulo PI))
		)
			(command "_.layer" "m" "TOP-TXT_AZIMUTE_DISTANCIA" "")
			(if (< (* 14 h) DS )
				(progn
					(command "TEXT"  "M" (polar P3 (rem (+ BB (/ PI 2.0))(* PI 2.0)) h) h (rtd angulo) TXTDS)
					(command "TEXT"  "M" (polar P3 (rem (+ BB (* PI 1.5))(* PI 2.0)) h) h (rtd angulo) AA)
				);;FIM DO ENTAO
				(progn
					(setq PT3 (getpoint "\nOnde quer escrever?:"));;#######################################################################################
					(setq DX (- (car MEIO) (car PT3)))
					(command "_.TEXT" "M" pT3 h 0 AA)
					(setq PT3 (cal "PT3-[0,2*h]"))
					(command "_.TEXT" "M" pT3 h 0 TXTDS)
					(setq PT3 (cal "PT3+[-6*h,0.95*h]"))
					(setq pT1 (cal "pT3+[12*h,0]"))
					(command "_.layer" "m" "TOP-LINHA_CHAMADA" "")
					(command "_.Pline" pt1 pt3 "") 
					(if (> DX 0.0)
						(command "_.Pline" pt1 MEIO "")
						(command "_.Pline" pt3 MEIO "")
					)
				);;FIM DO SE NAO
			);;FIM DO IF

		(initang)
		)
    (princ)
)

(defun C:ADE11 ( / DX MEIO PT1 PT2 PT3 intsegundo TXTDS TXTsegundo DIST)
(prompt "\nCalcula e escreve azimute e distancia.")
    (setq hakr 0)
    (setq zero 0.0)
    (ver_regua)
    (setq h (getvar "TEXTSIZE"))
    (initang)
    (capaerre)
    (setvar "osmode" 1)
    (setq MEIO 0.0)
    (setq P1 (getpoint "\nPrimeiro ponto:"))
    (while
		(setvar "osmode" 1)
		(setq P2 (getpoint P1 "\nProximo ponto:"))
		(setvar "osmode" 0)
		(command "" P1 P2  "")
		(setq No (atof(rtos(cadr P1) 2 11)))
		(setq Eo (atof(rtos(car  P1) 2 11)))
		(setq Nf (atof(rtos(cadr P2) 2 11)))
		(setq Ef (atof(rtos(car  P2) 2 11)))
		;(setq No (atof(rtos(cadr P1) 2 4)))
		;(setq Eo (atof(rtos(car  P1) 2 4)))
		;(setq Nf (atof(rtos(cadr P2) 2 4)))
		;(setq Ef (atof(rtos(car  P2) 2 4)))
		(setq delta_e (- Ef Eo))
		(setq delta_n (- Nf No))
			(if (= delta_n zero)
				(setq AA "0.0000")
			 )
			(if (/= delta_n zero)
			   (progn 
			  (setq angrad (/ delta_e delta_n))
			  (setq AA (angtos (atan angrad) 0 11))
			   )
			)
		(setq angreal (atof AA))
			
		(if (and (>= delta_e zero) (>= delta_n zero)) ;; 1o Quadrante
		  (progn
			(princ "\n 1o quadrante")
			(setq angreal (- 90 angreal))
			(setq quadrante 1)
		  )
		  (if (and (>= delta_e zero) (<= delta_n zero)) ; 2o Quadrante
				(progn
					(princ "\n 2o quadrante")
					(setq angreal (- 270 angreal))
					(setq quadrante 2)
				)
				(if (and (<= delta_e zero) (<= delta_n zero));; 3o Quadrante
				  (progn
					  (princ "\n 3o quadrante")
					  (setq angreal (- 270 angreal))
					  (setq quadrante 3)
				  )
				  (if (and (<= delta_e zero) (>= delta_n zero));; 4o Quadrante
					(progn
						(princ "\n 4o quadrante")
						(setq angreal (- 450 angreal))
						(setq quadrante 4)
					)
				  )
				)
			  )
		)
		(setq grau (fix angreal))
		(setq temp (* 60 (- angreal grau)))
		(setq minuto (fix temp))
		(setq temp (* 60 (- temp minuto)))
		(setq grau (rtos grau 2 0))
		(if (= (strlen grau) 1) (setq grau (strcat "0" grau)))
		(setq minuto (rtos minuto 2 0))
		(if (= (strlen minuto) 1) (setq minuto (strcat "0" minuto)))
		(setq segundo "")
		(setq intsegundo (fix temp))
		(setq decsegundo (rtos( * (- temp intsegundo) 10) 2 0))
		(if (< intsegundo 10) (setq segundo (strcat "0" (rtos intsegundo 2 0)))(setq segundo (rtos intsegundo 2 0)))
		(if (= (strlen decsegundo) 0) (setq segundo (strcat segundo ",0")))
		(if (= (strlen decsegundo) 1) (setq segundo (strcat segundo "," decsegundo)))
		;;(if (= (strlen (rtos decsegundo 2 0)) 2) (setq segundo (strcat segundo "," (rtos decsegundo 2 0))))
		(setq AA (strcat "Az=" grau "%%D" minuto "'" segundo "\""))
		(resetang)
		(SETQ MEIO (cal "(P1+P2)/2"))
		(setq BB (angle P1 P2)
			DS (distance P1 P2)
			DS (/ DS KR)
			P3 (polar P1 BB (/ DS 2.0))
			P1 P2 
		)
		(setq TXTDS (tira_ponto (rtos DS 2 3)));;com precisão de três casas decimais
		(setq TXTDS (strcat TXTDS "m"))
		(setq angulo BB)
		(if (or (= quadrante 3) (= quadrante 4))
			(setq angulo (+ angulo PI))
		)
			(command "_.layer" "m" "TOP-TXT_AZIMUTE_DISTANCIA" "")
			(if (< (* 14 h) DS )
				(progn
					(command "TEXT"  "M" (polar P3 (rem (+ BB (/ PI 2.0))(* PI 2.0)) h) h (rtd angulo) TXTDS)
					(command "TEXT"  "M" (polar P3 (rem (+ BB (* PI 1.5))(* PI 2.0)) h) h (rtd angulo) AA)
				);;FIM DO ENTAO
				(progn
					(setq PT3 (getpoint "\nOnde quer escrever?:"));;#######################################################################################
					(setq DX (- (car MEIO) (car PT3)))
					(command "_.TEXT" "M" pT3 h 0 AA)
					(setq PT3 (cal "PT3-[0,2*h]"))
					(command "_.TEXT" "M" pT3 h 0 TXTDS)
					(setq PT3 (cal "PT3+[-6*h,0.95*h]"))
					(setq pT1 (cal "pT3+[12*h,0]"))
					(command "_.layer" "m" "TOP-LINHA_CHAMADA" "")
					(command "_.Pline" pt1 pt3 "") 
					(if (> DX 0.0)
						(command "_.Pline" pt1 MEIO "")
						(command "_.Pline" pt3 MEIO "")
					)
				);;FIM DO SE NAO
			);;FIM DO IF

		(initang)
		)
    (princ)
)
(defun C:ADEZ ( / DX MEIO PT1 PT2 PT3 intsegundo TXTDS TXTsegundo DIST)
(prompt "\nCalcula e escreve o azimute com precisão de 0 dígito e a distancia.")
    (setq hakr 0)
    (setq zero 0.0)
    (ver_regua)
    (setq h (getvar "TEXTSIZE"))
    (initang)
    (capaerre)
    (setvar "osmode" 1)
    (setq MEIO 0.0)
    (setq P1 (getpoint "\nPrimeiro ponto:"))
    (while
		(setvar "osmode" 1)
		(setq P2 (getpoint P1 "\nProximo ponto:"))
		(setvar "osmode" 0)
		(command "" P1 P2  "")
		(setq No (atof(rtos(cadr P1) 2 11)))
		(setq Eo (atof(rtos(car  P1) 2 11)))
		(setq Nf (atof(rtos(cadr P2) 2 11)))
		(setq Ef (atof(rtos(car  P2) 2 11)))
		(setq delta_e (- Ef Eo))
		(setq delta_n (- Nf No))
			(if (= delta_n zero)
				(setq AA "0.0000")
			 )
			(if (/= delta_n zero)
			   (progn 
			  (setq angrad (/ delta_e delta_n))
			  (setq AA (angtos (atan angrad) 0 11))
			   )
			)
		(setq angreal (atof AA))
			
		(if (and (>= delta_e zero) (>= delta_n zero)) ;; 1o Quadrante
		  (progn
			(princ "\n 1o quadrante")
			(setq angreal (- 90 angreal))
			(setq quadrante 1)
		  )
		  (if (and (>= delta_e zero) (<= delta_n zero)) ; 2o Quadrante
				(progn
					(princ "\n 2o quadrante")
					(setq angreal (- 270 angreal))
					(setq quadrante 2)
				)
				(if (and (<= delta_e zero) (<= delta_n zero));; 3o Quadrante
				  (progn
					  (princ "\n 3o quadrante")
					  (setq angreal (- 270 angreal))
					  (setq quadrante 3)
				  )
				  (if (and (<= delta_e zero) (>= delta_n zero));; 4o Quadrante
					(progn
						(princ "\n 4o quadrante")
						(setq angreal (- 450 angreal))
						(setq quadrante 4)
					)
				  )
				)
			  )
		)
		(setq grau (fix angreal))
		(setq temp (* 60 (- angreal grau)))
		(setq minuto (fix temp))
		(setq temp (* 60 (- temp minuto)))
		(setq grau (rtos grau 2 0))
		(if (= (strlen grau) 1) (setq grau (strcat "0" grau)))
		(setq minuto (rtos minuto 2 0))
		(if (= (strlen minuto) 1) (setq minuto (strcat "0" minuto)))
		(setq segundo "")
		(setq intsegundo (rtos temp 2 0))
		;(setq decsegundo (rtos( * (- temp intsegundo) 10) 2 0))
		(if (= (strlen intsegundo) 0)(setq segundo "00"))
		(if (= (strlen intsegundo) 1) (setq segundo (strcat "0" intsegundo)))
		(if (= (strlen intsegundo) 2) (setq segundo intsegundo))
		;(if (= (strlen decsegundo) 0) (setq segundo (strcat segundo ",0")))
		;(if (= (strlen decsegundo) 1) (setq segundo (strcat segundo "," decsegundo)))
		;;(if (= (strlen (rtos decsegundo 2 0)) 2) (setq segundo (strcat segundo "," (rtos decsegundo 2 0))))
		(setq AA (strcat "Az=" grau "%%D" minuto "'" segundo "\""))
		(resetang)
		(SETQ MEIO (cal "(P1+P2)/2"))
		(setq BB (angle P1 P2)
			DS (distance P1 P2)
			DS (/ DS KR)
			P3 (polar P1 BB (/ DS 2.0))
			P1 P2 
		)
		(setq TXTDS (tira_ponto (rtos DS 2 3)));;com precisão de três casas decimais
		(setq TXTDS (strcat TXTDS "m"))
		(setq angulo BB)
		(if (or (= quadrante 3) (= quadrante 4))
			(setq angulo (+ angulo PI))
		)
			(command "_.layer" "m" "TOP-TXT_AZIMUTE_DISTANCIA" "")
			(if (< (* 14 h) DS )
				(progn
					(command "TEXT"  "M" (polar P3 (rem (+ BB (/ PI 2.0))(* PI 2.0)) h) h (rtd angulo) TXTDS)
					(command "TEXT"  "M" (polar P3 (rem (+ BB (* PI 1.5))(* PI 2.0)) h) h (rtd angulo) AA)
				);;FIM DO ENTAO
				(progn
					(setq PT3 (getpoint "\nOnde quer escrever?:"));;#######################################################################################
					(setq DX (- (car MEIO) (car PT3)))
					(command "_.TEXT" "M" pT3 h 0 AA)
					(setq PT3 (cal "PT3-[0,2*h]"))
					(command "_.TEXT" "M" pT3 h 0 TXTDS)
					(setq PT3 (cal "PT3+[-6*h,0.95*h]"))
					(setq pT1 (cal "pT3+[12*h,0]"))
					(command "_.layer" "m" "TOP-LINHA_CHAMADA" "")
					(command "_.Pline" pt1 pt3 "") 
					(if (> DX 0.0)
						(command "_.Pline" pt1 MEIO "")
						(command "_.Pline" pt3 MEIO "")
					)
				);;FIM DO SE NAO
			);;FIM DO IF

		(initang)
		)
    (princ)
)
(defun c:ECE ()
 (setq old_mode (getvar "OSMODE"))
 (setvar "osmode" 512)
 (setvar "dimzin" 0)
 (capaerre)
 (ver_regua)
 (prompt "\nElementos da Curva Circular.")
 (setq en     (entsel   "\nSelecione a Curva: "))
 (setvar "osmode" 0)
 (if en (setq en (car en)))
 (setq ed     (entget en)
       pt2    (getpoint "\nOnde vai escrever: ")
       ppt2   (getpoint pt2 "\nDireção da escrita: ")
       centro (reverse (cdr (reverse (cdr (assoc 10 ed)))))
;      e      (rtos (car  centro) 2 4)
;      n      (rtos (cadr centro) 2 4)
       r      (/ (cdr (assoc 40 ed)) kr)
       angul0 (cdr (assoc 50 ed))
       angul1 (cdr (assoc 51 ed))
       raio   (strcat "R=" (rtos r 2 3))
       angcen (+ (- angul1 angul0) 0.00000000000)
;       bisset (/ (* 180 (/ (+ angul1 angul0) 2)) 3.1415926535)
       h      (getvar "TEXTSIZE")
;       pt3    (list (+ (car pt2) (* 1.2 h)) (+ (cadr pt2) (* 3.75 h) ))
       pt5    (polar pt2 (/ pi 4) h)
       pt6    (polar pt5 (/ pi 2) (* h 4))
       pt7    (polar pt6 (/ pi 4) h)
       pt8    (polar pt2 (/ pi -4) h)
       pt9    (polar pt8 (/ pi -2) (* h 4))
       pt10   (polar pt9 (/ pi -4) h)

 )
 (if ppt2 (setq angt (/ (* 180 (angle pt2 ppt2)) 3.1415926535)) (setq angt 0))
 (setq pt2 (list (car pt2) (cadr pt2)))
 (setq angti (- angt 90.0))
 (setq angti1 (+ angt 90.0))
 (setq pt3 (cal "pt2+[7.2*h<angti1]"))
 (setq pt4 (cal "pt3+[0.31144*h<angti]"))
 (if (< angcen 0) (setq angcen (+ (- angul1 angul0) (* 2 3.1415926535))))
 (setq bisset (/ (* 180 (+ angul0 (/ angcen 2))) 3.1415926535))
 (setq d      (* r angcen)
       Fi (/ angcen 2)
       Lammda (sin Fi)
       Ta (/ (sin (- (/ 3.1415926535 2) Fi)) (cos (- (/ 3.1415926535 2) Fi)))
       DPiCe (cal "kr*r*(sqrt(1-Lammda^2)+(Lammda/Ta))")
       PIH (cal "centro+[DPiCe<bisset]")
       e      (strcat "   " (rtos (car  PIH) 2 4))
       n      (strcat "   " (rtos (cadr PIH) 2 4))
       acd    (rtd angcen)
       graus  (fix acd)
       dmin   (* 60 (frac acd))
       min    (fix dmin)
       seg    (* 60 (frac dmin))
       acg    (strcat (rtos graus 2 0))
       acm    (strcat (rtos min 2 0))
       acs    (strcat (rtos seg 2 1 ))
       ac     (strcat "AC=" acg "%%d" acm"'" acs"''")
       desen  (strcat "D=" (rtos d 2 3))
       ang2   (/ angcen 2)
       t      (* r (/ (sin ang2) (cos ang2)))
       tang   (strcat "Tg=" (rtos t 2 3)))

  (If (> angcen pi) (setq tang "Tangente Indefinida"))

 (command "text" pt3 h angt n
	  "text" "" e
	  "text" "" raio
;	  "text" "" 
	  "text" "" ac
	  "text" "" desen
	  "text" "J" "ML" pt4 h angt "PI="
;         "text" "" tang
 )
;;; (setq pt11 (cal "pt3+[7.2*h<angti]"))
 (setq pt12 (cal "pt2+[11*h<angt]"))
 (command "_.Color" 1)
 (command "_.PLine" pt2 pt12 PIH "")
 (command "_.Color" "bylayer")
 (setvar "osmode" old_mode)
)

;----------------------------------------

(defun c:ECE2 ()
 (setq old_mode (getvar "OSMODE"))
 (setvar "osmode" 512)
 (setvar "dimzin" 0)
 (capaerre)
 (ver_regua)
 (prompt "\nElementos da Curva Circular.")
 (setq exemplo (entsel   "\nSelecione uma Curva: "))
 (setq crit (list (cons 0 "ARC") (assoc 8 (entget (car exemplo)))))
 (setq allarcs (ssget "x" crit))
 (setq lallarcs (sslength allarcs))

(while (> lallarcs 0)
 (setq lallarcs (1- lallarcs)) 
 (setq en (ssname allarcs lallarcs))
 (setvar "osmode" 0)
 (setq ed     (entget en)
       centro (reverse (cdr (reverse (cdr (assoc 10 ed)))))
       r      (/ (cdr (assoc 40 ed)) kr)
       angul0 (cdr (assoc 50 ed))
       angul1 (cdr (assoc 51 ed))
       raio   (strcat "R=" (rtos r 2 3))
       angcen (+ (- angul1 angul0) 0.00000000000)
       bisset (/ (* 180 (/ (+ angul1 angul0) 2)) 3.1415926535)
       ptmed (cal "centro+[r<bisset]")
       h      (getvar "TEXTSIZE")
;       pt3    (list (+ (car pt2) (* 1.2 h)) (+ (cadr pt2) (* 3.75 h) ))
;       pt5    (polar pt2 (/ pi 4) h)
;       pt6    (polar pt5 (/ pi 2) (* h 4))
;       pt7    (polar pt6 (/ pi 4) h)
;       pt8    (polar pt2 (/ pi -4) h)
;       pt9    (polar pt8 (/ pi -2) (* h 4))
;       pt10   (polar pt9 (/ pi -4) h)
 )
 (if (< angcen 0) (setq angcen (+ (- angul1 angul0) (* 2 3.1415926535))))
 (setq d (* r angcen))
 (command "_.Change" en "" "p" "c" "255" "")
 (command "_.Zoom" "C" ptmed d)
 (setq pt2 (getpoint "\nOnde vai escrever: "))
(if pt2 (progn
 (setq ppt2 (getpoint pt2 "\nDireção da escrita: "))
 (if ppt2 (setq angt (/ (* 180 (angle pt2 ppt2)) 3.1415926535)) (setq angt 0))
 (setq pt2 (list (car pt2) (cadr pt2)))
 (setq angti (- angt 90.0))
 (setq angti1 (+ angt 90.0))
 (setq pt3 (cal "pt2+[7.2*h<angti1]"))
 (setq pt4 (cal "pt3+[0.31144*h<angti]"))
 (setq Fi (/ angcen 2)
       Lammda (sin Fi)
       Ta (/ (sin (- (/ 3.1415926535 2) Fi)) (cos (- (/ 3.1415926535 2) Fi)))
       DPiCe (cal "kr*r*(sqrt(1-Lammda^2)+(Lammda/Ta))")
       PIH (cal "centro+[DPiCe<bisset]")
       e      (strcat "   " (rtos (car  PIH) 2 4))
       n      (strcat "   " (rtos (cadr PIH) 2 4))
       acd    (rtd angcen)
       graus  (fix acd)
       dmin   (* 60 (frac acd))
       min    (fix dmin)
       seg    (* 60 (frac dmin))
       acg    (strcat (rtos graus 2 0))
       acm    (strcat (rtos min 2 0))
       acs    (strcat (rtos seg 2 0 ))
       ac     (strcat "AC=" acg "%%d" acm"'" acs"''")
       desen  (strcat "D=" (rtos d 2 3))
       ang2   (/ angcen 2)
       t      (* r (/ (sin ang2) (cos ang2)))
       tang   (strcat "Tg=" (rtos t 2 3)))

  (If (> angcen pi) (setq tang "Tangente Indefinida"))

 (command "text" pt3 h angt n
	  "text" "" e
	  "text" "" raio
;	  "text" "" 
	  "text" "" ac
	  "text" "" desen
	  "text" "J" "ML" pt4 h angt "PI="
;         "text" "" tang
 )
;;; (setq pt11 (cal "pt3+[7.2*h<angti]"))
 (setq pt12 (cal "pt2+[11*h<angt]"))
 (command "_.Color" 1)
 (command "_.PLine" pt2 pt12 PIH "")
 (command "_.Color" "bylayer")
))
 (command "_.Change" en "" "p" "c" "bylayer" "")
)
 (setvar "osmode" old_mode)
)

;----------------------------------------


(defun c:ECI ()
 (setq old_mode (getvar "OSMODE"))
 (setvar "osmode" 512)
 (capaerre)
;(ver_regua)
 (prompt "\nElementos da Curva Circular ** Por Fabricio Leal 1996 **")
 (setq en     (entsel   "\nSelecione a Curva: "))
 (setvar "osmode" 0)
 (setq ed     (entget (car en))
       pt1    (cadr en)
       centro (cdr (assoc 10 ed))
       e      (strcat "         E  =  " (rtos (car  centro) 2 4))
       n      (strcat "         N  = " (rtos (cadr centro) 2 4) "           .......... Ponto Central")
       r      (/ (cdr (assoc 40 ed)) kr)
       angul0 (cdr (assoc 50 ed))
       angul1 (cdr (assoc 51 ed))
       raio   (strcat "         R  = " (rtos r 2 3) "                 .......... Raio")
       angcen (+ (- angul1 angul0) 0.00000000000)
       h      (getvar "TEXTSIZE")

 )
 (if (< angcen 0) (setq angcen (+ (- angul1 angul0) (* 2 pi))))
 (setq d      (* r angcen)
       acd    (rtd angcen)
       graus  (fix acd)
       dmin   (* 60 (frac acd))
       min    (fix dmin)
       seg    (* 60 (frac dmin))
       acg    (strcat (rtos graus 2 0))
       acm    (strcat (rtos min 2 0))
       acs    (strcat (rtos seg 2 0))
		 ac     (strcat "         AC = " acg (chr 248) acm 
		      (chr 39) acs (chr 39) (chr 39) "             .......... Angulo Central")
       desen  (strcat "         D  = " (rtos d 2 3) "                 .......... Desenvolvimento")
       ang2   (/ angcen 2)
       t      (* r (/ (sin ang2) (cos ang2)))
       tang   (strcat "         TG = " (rtos t 2 3) "                 .......... Tangente")
 )


  (If (> angcen pi) (setq tang "Tangente Indefinida"))

(textpage)


(prompt "\n---------------------- ** by Fabricio Leal 1996 ** -----------------------")
(prompt "\n--------------------------------------------------------------------------")
(prompt "\n                           Elementos de Curva")
(prompt "\n--------------------------------------------------------------------------")
(prompt "\n")
(prompt "\n")
(princ raio)
(prompt "\n")
(prompt "\n")
(princ ac)
(prompt "\n")
(prompt "\n")
(princ desen)
(prompt "\n")
(prompt "\n")
(princ tang)
(prompt "\n")
(prompt "\n")
(princ n)
(prompt "\n")
(princ e)
(prompt "\n")
(prompt "\n--------------------------------------------------------------------------")
(prompt "\n")
(getint "\n               Digite ENTER para voltar ao modo grafico.")
(graphscr)
(prompt "\n \n \n") 

 (setvar "osmode" old_mode)
)




;----------------------------------------



(defun C:COE (/ n e pt1 pt2) ;  h ts)
    (resetang)
    (capaerre)
    (ver_regua)
    (setq h (getvar "textsize")
	  e0 0
	  n0 0
    )
	(setq oldosmode (getvar "osmode"))
    (setvar "osmode" 41)
    (prompt "\nESCREVE A COORDENADA UTM DO PONTO *** Verifique as constantes *** ")
     (princ (strcat "\nN0 = "(rtos n0 2 3)" E0 = "(rtos e0 2 3)))
     (setq pt1 (getpoint "\nOrigem da coordenada : "))
     (setvar "osmode" 0)
     (setq pt2 (getpoint "\nOnde  vai   escrever : ")
	   e   (car  pt1)
	   n   (cadr pt1)
     )
      (setq ts (tblsearch "STYLE" (getvar "TEXTSTYLE"))
;            h (cdr (assoc 40 ts))
      )
      ;Prompt for rotational angle of text
      (if (null a$$)
	  (progn
	   (if (= (cdr (assoc 70 ts)) 4)  ; Vertical style text
	       (progn
		(setq a$$ 270)
		(prompt "\nDirecao da escrita <270>: ")
	       )
	       (progn
		(setq a$$ 0)
		(prompt "\nDirecao da escrita <0>: ")
	       )
	   )
	  )
	  (progn
	   (prompt "\nDirecao da escrita <")
	   (princ (strcat (angtos a$$) ">: "))
	  )
      )
      (setq ang (getangle pt2))
      (if (null ang) (setq ang a$$))
      (setq a$$ ang)


      (setq xe   (+ (car pt2) (* 2 h))
	    ye   (+ (cadr pt2) (/ h 2))
	    pt4   (list (car pt2) (cadr pt2))
	    elinha   (rtos (+ (- e e0) e0) 2 4)
	    nlinha   (rtos (+ (- n n0) n0) 2 4)
      )

      (setq afasta (* (/ escala fator) 0.5))    
      (setq ptxte (polar pt4 (- ang (/ pi 2.0)) afasta))        
	(setq flag T)
	(if (= (rtd ang) 180) (progn
				(setq ang 0)
		        	(setq flag nil)	
			        (setq ptxte (polar pt4 (- ang (/ pi 2.0)) afasta))
				(command "text" "Br" pt4 h (rtd ang) nlinha
			                 "text" "Tr" ptxte "" "" elinha)

			      )
                                (command "text" "BL" pt4 h (rtd ang) nlinha
			 		 "text" "TL" ptxte "" "" elinha)
	)



      (if (= deslin nil) (setq deslin "S"))
      (prompt "\nDesenha linha S/N ? <")
      (princ deslin)
      (setq DESLIN (strcase (Getstring "> : ")))
      (if (and (/= deslin "S") (/= deslin "N")) 
	  (setq deslin "S")
      )         
      (if (= deslin nil) (setq deslin "S"))
      (setvar "osmode" 0)

      (if (= deslin "S")
	(progn

	  (if (= poslin nil) (setq poslin "D"))
	  (prompt "\nPosicao da linha de arrasto a Direita ou a Esquerda D/E ? <")
	  (princ poslin)
	  (setq temp (strcase (Getstring "> : ")))
	  (if (or (= temp "D") (= temp "E")) 
		(setq poslin temp)
	  )

	  (setq afasta (* (/ escala fator) 1))
	  (if flag (setq ptlin1 (polar pt4 (- ang pi) afasta)) (setq ptlin2 (polar pt4 ang afasta)))	 
	  (setq tamlin (* 0.825547 (* (/ escala fator) (* h 14))))
	  (if flag (setq ptlin2 (polar pt4 ang tamlin)) (setq ptlin1 (polar pt4 pi tamlin)))

    (princ)
	  (if (= poslin "D")
		(command "line" ptlin1 ptlin2 PT1 "")
		(command "line" ptlin2 ptlin1 PT1 "")
	  )

	)
      )
      (setvar "osmode" oldosmode)
			(princ)

)



(defun C:ELC ( / echo)
   (setq echo (getvar "CMDECHO"))
   (setvar "CMDECHO" 0)
   (prompt "\nSelecione as entidades que serao mudadas para o layer corrente: ")
   (COMMAND "SELECT" "AU" PAUSE)
   (COMMAND "CHANGE" "P" "" "P" "LA" (GETVAR "clayer") "")
   (setvar "CMDECHO" echo)
   (princ)
); Defun ELC






(defun C:ELS (/ s1 s2 lname echo)
   (setq echo (getvar "CMDECHO"))
   (setvar "CMDECHO" 0)
   (princ "\nSelecione todas as entidades que serao mudadas para um layer base: ")
   (setq s1 (ssget))
   (setq ent (entsel "\nSelecione uma entidade do layer base: "))
   (if (NULL ent); 
      (while (NULL ent)
	 (princ "\nTente novamente ou pressione ^C para sair: ")
	 (setq ent (entsel))
      ); While
   ): If
   (setq ent (entget (car ent)))
   (setq lname (cdr (assoc 8 ent)))
   (COMMAND ".CHANGE" s1 "" "PROP" "LAYER" lname "")
   (setvar "CMDECHO" echo)
   (princ)
); Defun CHGL




(defun c:LCD (/ p x OorF)
(prompt "\nCongela (Freeze) ou Desliga (Off) o layer de um objeto selecionado.") 
(setq x (entsel "\nSelecione o objeto: "))
(initget "Off Freeze")
(setq OorF (getkword "\nFreeze/<Off>: "))
(setq p (cdr (assoc 8(entget (car x)))))
 (if(= OorF "Freeze")
    (command "layer" "Freeze" p "")
    (command "layer" "Off" p "")
 )
)

( defun  c:LOS ( / SEL OBJ LISTA_OBJ LISTA_LAY )
     ( setq SEL ( entsel "\nSelecione um objeto do novo LAYER CORRENTE: "))
     ( setq OBJ ( car SEL ))
     ( setq LISTA_OBJ ( entget OBJ ))
     ( setq LISTA_LAY ( assoc 8 LISTA_OBJ ))
     ( setq LAY ( cdr LISTA_LAY ))
     ( if (= ( getvar "clayer" ) LAY )
	 ( alert "ESSE objeto pertence ao \nlayer que esta ativo..." )
	 ( command "layer" "set" lay "" )
     )
)

(defun C:ISO (/ ent mlayer echo)
   (setq echo (getvar "CMDECHO"))
   (setvar "CMDECHO" 0)
   (setq ent (entsel "\nSelecione uma entidade do layer a ser isolado: "))
   (if (NULL ent)
      (while (NULL ent)
	 (princ "\nTente novamente ou pressione ^C para sair: ")
	 (setq ent (entsel))
      ); While
   ): If
   (setq ent (entget (car ent)))
   (setq mlayer (cdr (assoc 8 ent)))
   (COMMAND "LAYER" "S" MLAYER "F" "*" "")
   (setvar "CMDECHO" echo)
   (princ)
); Defun ISOLATE


(defun C:CON ()
   (setq echo (getvar "CMDECHO"))
   (setvar "CMDECHO" 0)
   (setq ent (entsel "\nSelecione um objeto do LAYER a congelar: "))
   (if (NULL ent); 
      (while (NULL ent)
	 (princ "\nTente novamente ou pressione ^C : ")
	 (setq ent (entsel))
      ); While
   ): If
   (setq ent (entget (car ent)))
   (setq mlayer (cdr (assoc 8 ent)))
   (COMMAND "LAYER" "f" MLAYER "")
   (setvar "CMDECHO" echo)
   (princ)
); Fim da Defun FREESER



(defun C:COP (/ s1 s2 lname echo p1)
   (setq echo (getvar "CMDECHO"))
   (setvar "CMDECHO" 0)
   (princ "\nSelecione todos os objectos que srao copiados: ")
   (setq s1 (ssget))
   (setq p1 (list 0 0 0))
   (command "_.COPY" s1 "" p1 p1)
   (setq ent (entsel "\nSelecione um objeto do layer para onde sera feita a copia: "))
   (if (NULL ent)
      (while (NULL ent)
	 (princ "\nTente novemente ou pressione ^C: ")
	 (setq ent (entsel))
      ); While
   )
   (setq ent (entget (car ent)))
   (setq lname (cdr (assoc 8 ent)))
   (COMMAND ".CHANGE" s1 "" "PROP" "LAYER" lname "")
   (setvar "CMDECHO" echo)
   (princ)
); Defun copia.


(defun c:ml()
	(setq sp (getpoint "\nEnter start point for leader: "))
	(command "dim1" "leader" sp pause "" "")
	(setq ep (getvar "lastpoint"))
	(setq txtht (getvar "dimtxt"))
	(setq txtpt (list 
			 (+ (car ep) 0.36) 
			 (- (cadr ep) (/ (getvar "dimtxt") 2))
		    )
	)
	(command "dtext" txtpt txtht 0 pause)
)


(defun c:MC ()
 (setq en (car (entsel "\nSelecione entidade que devera mudar de cor: ")))
 (setq el (entget en))
 (setq cl (getint "\nNovo numero da cor:"))
 (setq ocl (assoc 62 el))            ;old color
 (if ocl
  (setq el (subst (cons 62 cl) ocl el)) ;if color is
					;present
  (setq el (cons (cons 62 cl) el))   ;if color is
				     ;absent
 )
 (entmod el)
)



(defun azdt (ptorigem ptfim)
    (setq zero 0.0)
    (capaerre)
    (setq No (cadr ptorigem))
    (setq Eo (car  ptorigem))
    (setq Nf (cadr ptfim))
    (setq Ef (car  ptfim))
    (setq delta_e (- Ef Eo))
    (setq delta_n (- Nf No))
    (if (= delta_n zero)
	(setq angulo "0.0000")
    )
    (if (/= delta_n zero)
      (progn 
	 (setq angrad (/ delta_e delta_n))
	 (setq angulo (angtos (atan angrad) 0 4))
      )
    )
    (setq angreal (atof angulo))
   (if (and (>= delta_e zero) (>= delta_n zero))          ;; 1o Quadrante
     (progn
       (setq angreal (- 90 angreal))
       (setq grau (fix angreal))
       (setq temp (* 60 (- angreal grau)))
       (setq minuto (fix temp))
       (setq temp (* 60 (- temp minuto)))
       (setq segundo (fix temp))
       (setq grau (rtos grau 2 0))
       (setq minuto (rtos minuto 2 0))
       (setq segundo (rtos segundo 2 1))
     )
     (if (and (>= delta_e zero) (<= delta_n zero))        ;; 2o Quadrante
       (progn
	 (setq angreal (- 270 angreal))
	 (setq grau (fix angreal))
	 (setq temp (* 60 (- angreal grau)))
	 (setq minuto (fix temp))
	 (setq temp (* 60 (- temp minuto)))
	 (setq segundo (fix temp))
	 (setq grau (rtos grau 2 0))
	 (setq minuto (rtos minuto 2 0))
	 (setq segundo (rtos segundo 2 1))
       )
       (if (and (<= delta_e zero) (<= delta_n zero))      ;; 3o Quadrante
	 (progn
	   (setq angreal (- 270 angreal))
	   (setq grau (fix angreal))
	   (setq temp (* 60 (- angreal grau)))
	   (setq minuto (fix temp))
	   (setq temp (* 60 (- temp minuto)))
	   (setq segundo (fix temp))
	   (setq grau (rtos grau 2 0))
	   (setq minuto (rtos minuto 2 0))
	   (setq segundo (rtos segundo 2 1))
	 )
	 (if (and (<= delta_e zero) (>= delta_n zero))    ;; 4o Quadrante
	   (progn
	     (setq angreal (- 450 angreal))
	     (setq grau (fix angreal))
	     (setq temp (* 60 (- angreal grau)))
	     (setq minuto (fix temp))
	     (setq temp (* 60 (- temp minuto)))
	     (setq segundo (fix temp))
	     (setq grau (rtos grau 2 0))
	     (setq minuto (rtos minuto 2 0))
	     (setq segundo (rtos segundo 2 1))
	   )
	 )
       )
     )
   )

    (setq azimuteg (strcat "Az= " grau "%%D" minuto "'" segundo "''"))
    (setq azimutet (strcat "Az= " grau "ø " minuto "' " segundo "\""))
    (setq azimutec (strcat "Az= " grau "g " minuto "' " segundo "\""))
    (setq D1 (distance ptorigem ptfim))
    (setq dist (/ D1 KR))
    (setq dkr (rtos dist 2 2))
)





(defun fatorescala()
    (setq PEDEESCALA "\nEntre com a escala do desenho original ==> 1:")
    (if (= ESCALA nil)
      (progn
	(princ "\nMUDANCA DE ESCALA:")
	(princ "\nESCALA nao cadastrada!!!\n")
	(setq ESCALA (getreal PEDEESCALA))
	(setq temp 1000)
	(if (= ESCALA nil) (setq ESCALA temp))
	(princ (strcat "\nNova Escala ==> 1:" (rtos ESCALA 2 0)))
      )
    )
    (setvar "ltscale" (/ escala 100))
)

(defun c:att ()
    (setq elist (entget (car (entsel "\nAponte um texto: "))))
    (if (/= (cdr (assoc 0 elist)) "TEXT")
	(progn
	    (alert "NAO E' UM TEXTO")
	    (exit)
	)
    )
    (setq h (cdr (assoc 40 elist))
	  elayer (cdr (assoc 8 elist))
	  ecolor (cdr (assoc 62 elist))
    )
    (princ "\nTamanho do texto= ")
    (princ h)
    (if (= ecolor nil)
	(setvar "cecolor" "bylayer")
	(setvar "cecolor" (itoa ecolor))
    )
    (setvar "textsize" h)
    (command "layer" "set" elayer "" "" )
    (command "_dtext")
    (princ)
)

(defun c:atl ()
    (setq elist (entget (car (entsel "\nAponte uma Linha: "))))
    (if (/= (cdr (assoc 0 elist)) "LINE")
	(progn
	    (alert "NAO E' UMA LINHA")
	    (exit)
	)
    )
    (setq elayer (cdr (assoc 8 elist))
	  ecolor (cdr (assoc 62 elist))
	  etipo  (cdr (assoc 6 elist)))
    (command "layer" "set" elayer "" "" )
    (if (= ecolor nil)
	(setvar "cecolor" "bylayer")
	(setvar "cecolor" (itoa ecolor))
    )
    (if (= etipo nil)
	(setvar "celtype" "continuous")
	(setvar "celtype" etipo)
    )
    (command "_line")
    (princ)
)



(defun c:areg ()
    (prompt "\nCALCULO DE AREA DE UM POLIGONO REGULAR ** by ROGERIO AA 1995 **")
    (initang)
    (setq hakr 0)
    (setq NVERT nil)
    (setq EVERT nil)
    (capaerre)
    (ver_regua)
    (princ "\nEntre com a sequencia de vertices do poligono.")
    (setq origem (getpoint "\nAponte o ponto inicial. "))
    (princ origem)
    (setq NPRIM (cadr origem))
    (setq EPRIM (car origem))
    (setq varea 0.0)
    (setq NPRIM (cadr origem))
    (setq EPRIM (car origem))
    (setq N0 NPRIM)
    (setq E0 EPRIM)
    (while (or (/= NVERT NPRIM)(/= EVERT EPRIM))
       (princ "\nPasso 1")
       (setq vertice (getpoint "\nAponte o vertice. "))
       (princ vertice)
       (setq NVERT (cadr vertice))
       (setq EVERT (car vertice))
       (setq A (* 0.5 (* (+ NVERT N0) (- E0 EVERT))))
       (setq varea (+ varea A))
       (setq N0 NVERT)
       (setq E0 EVERT)
    )
    (princ "\nPoligono Fechado.")
    (setq varea (abs varea))
    (setq KR2 (* KR KR))
    (setq varea (/ varea KR2))
    (princ "\nArea calculada ==> ")
    (princ varea)
    (setq pttext (getpoint "\nTexto da area. Defina a origem."))
    (setq ang (getorient pttext "\nDe a direcao."))
    (setq v_area (rtos varea 2 2))
    (setq v_area (strcat v_area "m²"))
    (setq h (getvar "TEXTSIZE"))
    (command "_.TEXT" pttext h (- 90 (rtd ang)) v_area)
    (princ)
)

(defun c:areh ()
    (prompt "\nCALCULO DE AREA DE UM POLIGONO REGULAR ** by ROGERIO AA 1995 **")
    (initang)
    (setq hakr 0)
    (setq NVERT nil)
    (setq EVERT nil)
    (capaerre)
    (ver_regua)
    (princ "\nEntre com a sequencia de vertices do poligono.")
    (setq origem (getpoint "\nAponte o ponto inicial. "))
    (princ origem)
    (setq NPRIM (cadr origem))
    (setq EPRIM (car origem))
    (setq varea 0.0)
    (setq NPRIM (cadr origem))
    (setq EPRIM (car origem))
    (setq N0 NPRIM)
    (setq E0 EPRIM)
    (while (or (/= NVERT NPRIM)(/= EVERT EPRIM))
       (princ "\nPasso 1")
       (setq vertice (getpoint "\nAponte o vertice. "))
       (princ vertice)
       (setq NVERT (cadr vertice))
       (setq EVERT (car vertice))
       (setq A (* 0.5 (* (+ NVERT N0) (- E0 EVERT))))
       (setq varea (+ varea A))
       (setq N0 NVERT)
       (setq E0 EVERT)
    )
    (princ "\nPoligono Fechado.")
    (setq varea (abs varea))
    (setq KR2 (* KR KR))
    (setq varea (/ (/ varea KR2) 10000))
    (princ "\nArea calculada ==> ")
    (princ varea)
    (setq pttext (getpoint "\nTexto da area. Defina a origem."))
    (setq ang (getorient pttext "\nDe a direcao."))
    (setq v_area (rtos varea 2 4))
    (setq v_area (strcat v_area "ha"))
    (setq h (getvar "TEXTSIZE"))
    (command "_.TEXT" pttext h (- 90 (rtd ang)) v_area)
    (princ)
)


(defun c:par(/ valor) ;paralela
    (capaerre)
    (princ "\nATENCAO: ENTRE COM A DISTANCIA TOPOGRAFICA, SEM O KR !!!")
    (princ "\nDistancia Topografica <Through>: ")
    (setq valor (strcase(getstring)))
    (if (= (substr valor 1 1) "T")
     (command "offset" "T")
     (command "offset" (* kr (atof valor)))
    )
    (princ)
)


(defun c:sos()
(textpage)
(prompt "\nKR      => Cadastra e/ou mostra o KR existente.")
(prompt "\nLEROY   => Seleciona a regua e a escala.")
(prompt "\nDT DK   => Consulta distancia  Escreve distancia.");
(prompt "\nAREG    => Calcula a area de um poligono regular")
(prompt "\nACP     => Calcula a area de uma polilinha ou Circulo") 
(prompt "\nRPOLAR  => Desenha uma linha, dados a origem, a distancia e a direcao")
(prompt "\nAZC AZE => Consulta Azimute  Escreve Azimute.")
(prompt "\nADE     => Calcula e escreve de Azimute e Distancia.")
(prompt "\nADE4     => Calcula e escreve de Azimute e Distancia utilizando a precisção de 4 dígitos.")
(prompt "\nADE11    => Calcula e escreve de Azimute e Distancia utilizando a precisção de 11 dígitos.")
(prompt "\nADI     => Calcula e escreve de Azimute e Distancia.")
(prompt "\nCOE     => Escreve as coordenadas de ponto")
(prompt "\nCOI     => Informa as coordenadas de ponto")
(prompt "\nECE ECI => Escreve Elementos de Curva  Informa Elem Curvas")
(prompt "\nELC     => Muda entidade para o layer corrente")
(prompt "\nELS     => Muda entidade para o layer selecionado")
(prompt "\nLCD     => Congela ou Desliga um layer")
(prompt "\nCOP     => Cria a copia de uma entidade para o layer selecionado")
(prompt "\nISO     => Isola um layer, congelando os demais")
(prompt "\nLOS     => Faz o Layer de um Objeto Selecionada o corrente")
(prompt "\nCON     => Congela um layer")
(prompt "\nDELL    => Deleta o layer selecionado")
(prompt "\n--------------------------------------------------------------------------")
(getint "\n        Digite ENTER para voltar ao modo grafico. By Fabricio.")
(graphscr)
(prompt "\n \n \n") 
)
(defun c:of (/ a valor)
  (Prompt "\nOffset com Kr, para o layer atual")
  (capaerre)
  (princ "\nATENCAO: ENTRE COM A DISTANCIA TOPOGRAFICA, SEM O KR !!!")
  (princ "\nDistancia Topografica <Through>: ")
  (setq valor (strcase (getstring)) )
  (if (= (substr valor 1 1) "T")
   (command "offset" "T" pause pause "")
   (command "offset" (* kr (atof valor)) pause pause "")
  )
  (setq a (getvar "clayer"))
  (command "chprop" "L" "" "la" a "")
  (princ)
)


(princ ">")
(princ)







